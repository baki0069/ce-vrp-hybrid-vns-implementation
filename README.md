This project was part of a university project and will not be updated any further.

The following text is an extract from the written elaboration of the implementation. It is in German, but with the current state of machine learning it should be possible to translate it quickly and easily.

# Hausarbeit

Neben der Implementierung und Evaluation eines linearen Lösungsverfahrens für CEVRP ('capacitated electric vehicle routing problems') wird im Folgenden eine mögliche Implementierung eines hybriden metaheuristischen Verfahrens nach Grundlegung von [1] für das Finden effizienter Touren vorgestellt. Anschließend wird die Laufzeit dieses Verfahrens ermittelt. Unter einer Metaheuristik versteht man im Allgemeinen ein stochastisches Verfahren zur Ermittlung einer hinsichtlich einer Kostenfunktion lokal-optimalen Lösung eines üblicherweise np-schweren Problems [5, Kap. 0.1], [2, Kap. 6.2].

Die Implementierung eines Lösungsverfahrens wird in diesem Kontext mithin als erfolgreich bezeichnet, wenn dieses sämtliche im definierten Bezugsrahmen des Anwendungsfalls möglichen Ausprägungen des CEVRP gemäß den aufgeführten formal-definierten Kriterien lösen kann. Eine Ausprägung des CEVRP gilt zudem als gelöst, sofern alle Kunden von einem elektrischen Vehikel beliefert werden können. Es sei überdies darauf zu achten, dass die konkrete Implementierung des hybriden metaheuristischen Lösungsverfahrens möglichst effizient zu sein hat, um lange, unpraktikable Laufzeiten zu vermeiden.

## Beschreibung des metaheuristischen Lösungsverfahrens

Die hybride Metaheuristik besteht im Wesentlichen aus einem zweistufigen Eröffnungsverfahren [2, Kap. 6.2] und einer anschließenden iterativen Verfahrensweise zur Optimierung der aus dem Eröffnungsverfahren hervorgekommenen initialen Lösung. Der Optimierungsvorgang richtet sich hauptsächlich nach dem Kernstück dieses [[Algorithmus]]', nämlich der Metaheuristik, wohingegen die vorhergehenden Komponenten heuristische Ansätze abbilden. Das in dem [[Algorithmus]] eingesetzte Eröffnungsverfahren wird als knotenorientiert bezeichnet. Zunächst werden die Kundenknoten unter Zuhilfenahme dichtebasierten Clusterings disjunkten Teilmengen derart zugeordnet, dass jede Teilmenge einer räumlich zusammenhängenden Region entsprechen soll. Daraufhin wird für jedes Cluster der Clark-and-Wright-Savings-[[Algorithmus]] im Sinne von [3] angewandt, um unter Einhaltung der kapazitiven und elektrischen Vehikeln eigentümlichen Beschränkungen initiale Touren zu generieren [1, S. 251]. Der iterative Optimierungsvorgang entspricht einer variablen Nachbarschaftssuche. [1, S. 249]

Die variable Nachbarschaftssuche (VNS) ist eine systematische, kombinatorische Metaheuristik, die unter anderem eine vorgegebene Tourenplanungslösung zu optimieren ermöglicht [4, S. 1097]. Sie besteht aus mehreren lokalen Nachbarschaftsoperatoren, die auf die Initiallösung in einer bestimmten Reihenfolge iterativ angewandt werden [4, S. 1097 f.].

[1, S. 251] legt die für die VNS zu verwendende Nachbarschaftsstruktur dar. Diese besteht aus fünf Operatoren. Von diesen konnte allerdings die Implementierung des "l-interchange operations"-Operators [1, Kap. 4.4.2] aufgrund von Verständnisproblemen nicht zustandegebracht werden. Aus diesem Grund finden sich in der konkreten Implementierung lediglich vier Operatoren wieder. Diese sind dann die Übrigen, mithin der "Two-opt-move" [1, Kap. 4.4.1], "Inter route cross-exchange for EVRP" [1, Kap. 4.4.3], "$\lambda$-Exchange" [1, Kap. 4.4.4] sowie zuletzt die "Sequential insertion method" [1, Kap. 4.4.5]. Es sei jedoch bereits anzumerken, dass hinsichtlich der abstrakten Beschreibungsweise der Operatoren durch [1] einige Implementierungen derselben vermutlich nicht der Intention der Autoren genau entsprechen. Daher könnte es zu den Aussagen der ursprünglichen Autoren widerstreitenden Angaben in Bezug auf die Verfahrensweisen der Operatoren kommen.

### Programmaufbau Und Technische Details

Um der Komplexität der vorgegebenen Problemklasse der CEVRPs Genüge zu leisten, ist eine vielschichtige Programmarchitektur unerlässlich. Die darzustellende Vorgehensweise wurde paradigmatisch im Sinne der objektorientierten Programmierung unter Verwendung von Python sowie ergänzenden Bibliotheken implementiert. Die Objektorientiertheit ermöglicht die Modellierung der relevanten Objekte des Problems als Klassen und ihre Interaktion über Methodenaufrufe. Unter den vorgenannten Bibliotheken finden sich beispielsweise solche zum Loggen von Programmereignissen, das Visualisieren verarbeiteter Daten mithilfe von matplotlib und weitere wieder. Über bereits vordefinierte programmatische Strukturen hinaus wurden zusätzlich eigene Datenstrukturen angefertigt, um die Implementierung der hybriden Metaheuristik einfach und konzise zu halten.

Zur Konstruktion des CEVRP-Modells wird eine entsprechend benannte Klasse *CEVRPModel* definiert [*cevrp_model.py*]. Diese verfügt über Methoden zum Aufsuchen einer initialen Lösung durch dichtebasiertes Clustering [vgl. *cevrp_model.py*, Z. 49 ff.] sowie die konsekutive Anwendung des Clark-and-Wright-Saving-[[Algorithmus]]' [vgl. *cevrp_model.py*, Z. 63 ff.]. Die vorgenannte [[Modell]]-Klasse hält sämtliche zur Berechnung einer gültigen Lösung notwendigen Informationen über die Probleminstanz bereit. Darunter etwa Angaben über die Verteilung des Depots und der Kundenknoten im Erkenntnisraum sowie Fahrzeugdaten [vgl. *cevrp_model.py*, Z. 16 ff.]. Die Initialisierung des CEVRP-Modells erfolgt in [*main.py*].

Dem Raum, welcher die Existenz der Knoten und die aus ihnen bestehenden Touren konstituiert, wird eine Metrik unterstellt, die dem euklidischen Abstandsbegriff entspricht. Um dieser Anforderung zu genügen, wurde eine Klasse *Node* entworfen, die eine Operatorüberladung zur Kalkulation der euklidischen Distanz zu einem anderen, als Argument zu überliefernden Objekt derselben Klasse definiert [vgl. *node.py*, Z. 34 f. und Z. 57 ff.]. Das Zusammenfassen mehrerer Knoten (*Nodes*) zu einer *Tour* erfolgt vermittelst der gleichnamigen Aggregations-Klasse [*tour.py*]. Jede Tour beginnt und endet mit einem als Depot definierten Knoten. Die Norm einer Tour entspricht der Anzahl aller Knoten derselben [vgl. *tour.py*, Z. 55 f.]. Des Weiteren ermöglicht die Tour-Klasse die definitionsgemäße Berechnung der Kosten, die durch das Durchlaufen einer Tour entstehen. Darunter fallen Kosten hinsichtlich der zurückzulegenden Distanz sowie der den Kunden-Knoten inhärierenden Kosten [vgl. *tour.py*, Z. 142 ff.]. Erstere ergeben sich aus Batterie-Aufladekosten und Fahrkosten, wohingegen letztere die Service-Zeiten beim Kunden und ihre Nachfragemengen umfassen. Touren lassen sich zudem zu Tour-Plänen zusammenfassen [*tour_plan.py*]. Diese Obermenge von Touren befindet sich im programmatischen Kontext zwar in Verwendung, ist für eine detaillierte Untersuchung allerdings uninteressant.

Die treibende Kraft des Lieferungsprozesses besteht insbesondere aus dem Fuhrpark. Da jedem Fahrzeug dieselben Eigenschaften auferlegt werden, genügt es, eine Referenz zu lediglich einem Fahrzeug aufrechtzuerhalten. Dieses wird als Instanz einer Klasse *Vehicle* im Programm dargestellt [*vehicle.py*].

Sämtliche beschriebene Klassen verfügen zudem über eine Vielzahl von Hilfsmethoden und zweckdienlichen Klassenmethoden, die in dieser Ausführung zu Gunsten der Beschränktheit auf das Wesentliche unberücksichtigt bleiben.

Zur Gewährleistung der Validität einer gefundenen Lösung ist es unverzichtbar, eine Vorgehensweise zur Überprüfung der postulierten Nebenbedingungen zu schaffen. Jede neu geschaffene Tour muss einer Gültigkeitsprüfung unterzogen werden. Da die Überprüfung der Nebenbedingungen demnach häufig erfolgen muss [vgl. *cevrp_model.py*, Z. 119 ff.; vgl. *vnd/cevrp_optimizer.py*, Z. 32 ff. i. V. m. *vnd/cevrp_optimizer.py*, Z. 205, 209, 262, 266, 289], ist eine einfache Handhabbarkeit hinsichtlich dessen von Vorteil. Zur Modularisierung der Nebenbedingungen wurde sich dem Strategie-Entwurfsmuster bedient [6, Kap. 5, Strategy]. Konkret existiert eine Validierungsklasse *ConstraintValidationStrategy*, die eine auf Validität zu prüfende Tour unter den Bedingungen des jeweiligen Referenzvehikels und der Grenzbatterieladung beinhaltet. Darüber hinaus definiert die Validierungsklasse eine abstrakte Validierungsfunktion *is_valid(self: ConstraintValidationStrategy) -> bool*, die auf sich selbst, mithin auf den vorgenannten Objekten operiert. Jene Validierungsfunktion wird im Zuge der Instanziierung der Validierungsklasse spezifiziert. Somit lassen sich modularisierte, von dieser Klasse teilweise losgelöste Validierungsfunktionen definieren, solange sie dieselbe Parameterfolge annehmen. Diese besteht lediglich aus der Klasseninstanz selbst. Es werden zudem keine weiteren Parameter für die Validierungsfunktionen gebraucht, da sich alle notwendigen Daten aus den geschilderten Attributen ebendieser Klasse ergeben.

Es gibt vier Validierungsfunktionen. Die erste [*constraints.py*, Z. 27 f.] fordert den Beginn und das Ende einer jeden Tour beim Depot. [*constraints.py*, Z. 31 f.] garantiert, dass die Summe aller Kundennachfragemengen maximal der Grenzladung des Referenzvehikels entspricht. Die Erfüllung der Bedingung hinsichtlich der Grenzreichweite eines Fahrzeugs wird mittels [*constraints.py*, Z. 35 ff.] überprüft. Schließlich untersucht [*constraints.py*, Z. 45 ff.] die Validität der Batterieladungen für eine gegebene Tour.

Insbesondere während der variablen Nachbarschaftssuche (VNS) wird aufgrund ihres kombinatorischen Charakters oftmalig auf die Validität der neu entstehenden Touren geprüft. Die VNS ist in [cevrp_optimizer.py] implementiert. Sie bedient sich den oben genannten inter- und intratour-Operatoren, die in der Nachbarschaftsstruktur *NeighborhoodOperatorsImpl* definiert wurden [vgl. *vnd/neighborhood_operators.py*]. Es soll nun kurz auf jene Nachbarschaftsoperatoren eingegangen werden.

Jeder anzuwendene Nachbarschaftoperator wird mehrfach auf jede Tour oder auf jedes Paar von Touren angewandt. Es werden nur solche Tourenänderungen gespeichert (hier: die ursprüngliche\*n Tour\*en überschrieben), sofern diese unter Einhaltung der kapazitiven und durch die Nutzung von Elektrofahrzeugen einhergehenden Beschränkungen eine kostengünstigere Alternative darstellen.

- Cross-Exchange
Hierbei handelt es sich um eine Interrouten-Operation, in welcher zwei beliebig lange Teilsegmente zweier Touren ausgetauscht werden. Ein Teilsegment entspricht einer Teilmenge der Kundenknotenfolge in einer Tour. Nach [1, Kap. 4.4.2] wird gefordert, dass jeweils nur ein Teilsegment einer Tour die Kardinalität 1 besitzen darf. [vgl. *vnd/neighborhood_operators.py*, Z. 44 ff. i. V. m. *vnd/cevrp_optimizer.py*, Z. 217 ff.]

- Two-Lambda-Interchange
Ähnlich zum vorangegangenen Operator werden hierbei Teilsegmente zweier Touren einander ausgetauscht. Allerdings beschränkt sich hierbei die Länge beider Teilsegmente auf 2. Der vorliegende Interchange-Operator wird dann und nur dann endgültig ausgeführt, sofern die Kosten der neuen Kundenpermutationen kleiner ausfallen, als die unmodifizierten. [vgl. 1, Kap. 4.4.4; vgl. *vnd/neighborhood_operators.py*, Z. 77 ff. i. V. m. *vnd/cevrp_optimizer.py*, Z. 173 ff.]

- Two-Opt-Move
Dieser Intrarouten-Operator tauscht eine Folge von Kundenknoten zweier Teilsegmente derselben Tour aus. Dies wird solange wiederholt, bis eine Knotenpermutation gefunden wurde, die einen geringeren Kostenfunktionswert wiedergibt, oder ein festgelegter Timer abgelaufen ist. Der Timer verhindert, dass es zu einer Endlossschleife kommt, falls keine Permutation existiert, die nicht der bereits vorliegenden Knotenfolge der Tour entspricht und zugleich mit geringeren Kosten einhergeht. [vgl. 1, Kap. 4.4.1; vgl. *vnd/neighborhood_operators.py*, Z. 94 ff. i. V. m. *vnd/cevrp_optimizer.py*, Z. 274 ff.]

- Sequential-Insertion
Dieser Operator wird auf die Gesamtheit aller existierenden Kundenknoten in der gegebenen Ausprägung des CEVRP-Modells angewandt. Für jeden Kundenknoten soll eine Tour gesucht werden, derer er kein Element und dessen Zuweisung im Vergleich zu anderen gegebenen Möglichkeiten die kostengünstigste sei [vgl. 1, Kap. 4.4.5]. Um beim Problem der Ausreißerdetektion durch das einleitende dichtebasierte Clustering Abhilfe zu schaffen, werden jene Ausreißer priorisiert behandelt, um sie auf die kostengünstigste Weise in eine Tour zu inkludieren. [vgl. *vnd/neighborhood_operators.py*, Z. 143 ff.]

Für die Nutzung der Nachbarschaftsoperatoren muss über die Definition der der Operatoren hinaus eine Reihenfolge festgelegt werden, in welcher über die Nachbarschaftsstruktur iteriert wird [4, Abschnitt 2]. Diese Reihenfolge wird in [1, S. 255 ff.] dargelegt.

Im Folgenden wird bezugnehmend auf [*vnd/cevrp_optimizer*, Z. 38 - 170] sowie ausgelagerte Programmteile, die im gekennzeichneten Programmabschnitt aufgerufen werden, der Ablauf der Metaheuristik beschrieben. Es sei $N_s$ die Nachbarschaftsstruktur und die Menge $\{1, 2, 3, 4\}$ die Menge aller Werte, die $N_s$ annehmen kann. Die oben geschilderten Operatoren wurden hier als Zahlen kodiert. Der Two-Opt-Move entspreche der 1, Cross-Exchange der 2, Two-Lambda-Exchange der 3 und zuletzt der Sequential-Insertion der 4. Die VNS besteht aus zwei verschachtelten Schleifen. Die äußere Schleife bricht ab, falls $N_s > 4$. Zu Beginn sei $N_s \leftarrow 1$. Derjenige Nachbarschaftsoperator, worauf die Struktur derzeit zeigt, wird wiederholt ausgeführt. Das kostengünstigste Optimum wird sich gemerkt und der untergeordneten Schleife zugeführt.

Für die untergeordnete Schleife sei $N_k$ mit dem Wertebereich $\{1, 2\}$ definiert. Die semantische Zahlenkodierung ist identisch mit derjenigen für $N_s$. $N_k$ werde ebenfalls wiederholt auf das gefundene Optimum angewandt. Wird kein weiteres Optimum mit dem derzeitig aktiven Operator gefunden, dann sei $N_k \leftarrow N_k + 1$. Abbruchkriterium sei $N_k > 2$. Falls jedoch die lokale Suche nach einem weiteren Optimum erfolgreich gewesen sei, setze die Nachbarschaftsstruktur wieder zurück auf $N_k \leftarrow 1$. Selbiges Prinzip der Operatorauswahl kann analog auf die Struktur für die äußere Schleife übertragen werden. Für den Fall, dass kein weiteres lokales Optimum durch die Anwendung eines Operators $N_s$ nach Bearbeitung durch die untergeordnete Schleife gefunden wurde, wird auf den nächsten Operator $N_s \leftarrow N_s + 1$ gezeigt. Für jedes gefundene lokale Optimum setzt sich die anzuwendene Nachbarschaftsstruktur zurück auf den ersten Nachbarschaftsoperator, d. h. $N_s \leftarrow 1$. Sobald für eine definierte Vielzahl an aufeinanderfolgenden Iterationen sämtliche Nachbarschaftsstrukturen kein lokales Optimum finden konnten, wird der derzeitige Tourenplan zurückgegeben.

## Laufzeit

Wie bereits geschildert, besteht der zu untersuchende [[Algorithmus]] aus drei Hauptkomponenten: aus dem dichtebasierten Clustering, dem CWSA und der VNS. Um die gesamte Laufzeit des vorliegenden [[Algorithmus]] festzustellen, müssen die einzelnen Laufzeiten seiner Bestandteile untersucht werden.

Für das dichtebasierte Clustering wurde die vordefinierte Funktion *DBSCAN* aus der externen Bibliothek *sklearn.cluster* genutzt. Daher wird hinsichtlich der Laufzeit dieser Komponente auf die entsprechende Dokumentation verwiesen [7, unter 'Notes'].

Der CWSA besteht aus insgesamt vier Schleifen. Die übergeordnete while-Schleife bricht ab, sobald keine neuen Savings-Werte generiert werden können [vgl. *cevrp_model.py*, Z. 79 ff.]. Darin befinden sich die übrigen Schleifen. Im ersten wesentlichen Schleifendurchlauf wird eine Liste aus Savings-Werten erzeugt mit Laufzeit $\Theta(k_i^2), \;k_i:=\text{Anzahl Touren in Iteration i}$ [vgl. *cevrp_model.py*, Z. 82 - 90]. Daraufhin wird über dieselbe Liste iteriert mit identischer Laufzeit. Damit wurden alle bezüglich der Laufzeituntersuchung wesentlichen Programmstrukturen für den CWSA in Betracht gezogen. Hieraus ergibt sich mithin eine obere Schranke $\mathcal O(2*c*k_i^2)$ mit c als Gesamtanzahl an Iterationen für die Laufzeit.

Zur Laufzeitabschätzung der VNS müssen ihre genutzten Nachbarschaftsoperatoren untersucht werden.

Der Two-Opt-Move weist eine obere Laufzeitschranke von $\mathcal O(k*i*n)$ auf; k sei die Anzahl an Touren [vgl. *vnd/cevrp_optimizer.py*, Z. 275 ff.], i die Anzahl definitorisch festgesetzter Durchläufe und n die Anzahl an Iterationen innerhalb eines Durchlaufs zum Auffinden einer günstigeren Lösung [vgl. *vnd/neighborhood_operators.py*, Z. 94 ff.].

Für den Cross-Exchange kann eine obere Schranke von $\mathcal O(k^2*n)$ festgestellt werden; $k$ und $n$ vertreten hierbei die gleichen Sachverhalte wie bei obiger Laufzeituntersuchung [vgl. *vnd/cevrp_optimizer.py*, Z. 217 ff. und *vnd/neighborhood_operators.py*]. Der Two-Lambda-Interchange fügt wegen [*vnd/cevrp_optimizer.py*, Z. 183] der Laufzeit einen Faktor $|E_{k_i}|^2$ hinzu. Die Basis $|E_{k_i}|$ bezeichnet die Anzahl aller Kanten einer gegebenen Tour im Iterationsdurchlauf $i$. Somit liegt hier eine obere Schranke von $\mathcal O(|E_{k_i}|*k^2*n)$ vor.

Der Sequential-Insertion-Operator geht zunächst in zwei separaten Schleifen insgesamt sämtliche Knoten des Modells durch. Daher gilt wegen [*vnd/neighborhood_operators.py*, Z. 160 - 176] zur Erstellung  und Sortierung der Distanzliste zum Depot eine Laufzeit von $\mathcal O(|V_o|+|V_o|*log(|V_o|)+|V_c|+|V_c|*log(|V_c|))=\mathcal O(|V_o|*log(|V_o|)+|V_c|*log(|V_c|)$; $|V_o|$ sei die Kardinalität der Menge aller Ausreißerknoten und $|V_c|$ jene der Menge aller übrigen Knoten. Bei der Distanzliste handelt es sich um ein Dictionary mit $(v_i,\;d(v_i,\,v_0))\;\;\forall v_i\in V_M,\;v_o:=\text{Depot},\;d: \text{Distanzfunktion,}$ als Schlüssel-Wert-Paare. Da wie eingangs erwähnt $|V_o| + |V_c| = |V_M|$ mit $|V_M|$ als Gesamtanzahl aller Knoten des Modells gilt, lässt sich der Ausdruck für die Laufzeit vereinfachen zu $\mathcal O(|V_M|*log(|V_M|))$. Anschließend wird über die eben erstellte Liste iteriert und es werden Pendeltouren $(v_i, w_l)\;\forall v_i\in V_M,\;\forall w_l\in k_j, \forall k_j \in K, K: Tourenplan$ erstellt [*vnd/neighborhood_operators.py*, Z. 184 - 210]. Zur Konstruktion der Pendeltouren besteht mithin eine obere Schranke von $\mathcal O(|V_m|*max_{\forall k_j\in K}(|k_j|)*|K|)$. Schließlich werden sämtliche Pendeltouren sequentiell abgearbeitet [*vnd/neighborhood_operators.py*, Z. 212 ff.]. Es ist somit insgesamt $\mathcal O(|V_M|*log(|V_M|)+|V_M|*|K|*(2*|k|))$ mit $|k|:=max_{\forall k_j\in K}(|k_j|)$. Dies lässt sich folgendermaßen vereinfachen: $\mathcal O(|V_M|*(log(|V_M|)+2*|k|*|K|))$. Da meistens $log(|V_M|) = \mathcal O(2*|k|*|K|)$ gilt, lässt sich die obere Schranke nochmals umschreiben zu: $\mathcal O(2*|V_M|*|k|*|K|).

Aus der durchgeführten Untersuchung wird evident, dass die VNS den hybriden metaheuristischen [[Algorithmus]] laufzeitmäßig dominiert. Es wurde gezeigt, dass die Laufzeit sämtlicher Nachbarschaftsoperatoren stark von der Anzahl vorliegender Touren abhängt. Die Länge dieser Touren sind für fast alle Operatoren nicht tragend. Daraus lässt sich schließen, dass trotz der Laufzeitdominanz der VNS ein in Bezug auf die Tourengestaltung optimierter CWS- und Clustering-[[Algorithmus]] ebenfalls nicht unerhebliche Auswirkungen auf die VNS hat.

## Kritische Würdigung Der Ergebnisse

Aus den Abbildungen im Abbildungsverzeichnis lassen sich für die Kundenknotenanzahlen 15, 20 und 25 einige Teilergebnisse nach dem Clustering-Verfahren und dem CWSA einsehen. Des Weiteren findet sich unter den Abbildungen solche, die die Gesamtkosten und die Besuchsquote der CEVs bei den Kundenknoten des Tourenplans für die angegebenen Knotenanzahlen ab Übergabe der Initiallösung durch den CWSA an die VNS darstellen. Aus diesen lässt sich erkennen, dass nach Ablauf der VNS sämtliche Kundenknoten besucht werden. Zudem lässt sich bei allen Verläufen feststellen, dass die Gesamtkosten über die Dauer der Metaheuristik abnehmen. Im Vergleich zu den Initallösungen ist des Weiteren erkennbar, dass die Touren der endgültigen Lösungen konvexere Formen annehmen. Daraus lässt sich schließen, dass die Touren in ihrer endgültigen Fassung effizienter durchlaufen werden, da die Fahrverläufe der CEVs sich weniger kreuzen.

Insgesamt scheint unser eingangs formuliertes Ziel erfüllt worden zu sein; es werden für jegliche Ausprägungen des CEVRPs Tourenpläne erzeugt, die sämtliche Kundenknoten abdecken, und durch die VNS lassen sich verglichen mit den initialen Lösungen zunehmend effizientere finden. Andererseits lassen sich auch Schwächen in der Umsetzung finden.

Die Gleichgültigkeit des metaheuristischen Programms gegenüber Eigenschaften des betrachteten Fuhrparks, die in der Praxis richtungsweisend sein können, gibt beispielsweise Anlass für Kritikäußerung. Die implementierte Metaheuristik berücksichtigt die begrenzte Anzahl verfügbarer elektrisch betriebener Fahrzeuge nur unzureichend. Im Fall der Homogenität des Fuhrparks mag zwar die Mehrfachnutzung eines elektrischen Fahrzeugs, mithin die formelle Zuweisung mehrerer Touren für jeweils ein Fahrzeug, im Zweifelsfall ein mögliches begründetes Argument sein. Dieses verliert jedoch an argumentativer Haltbarkeit und Relevanz in Anbetracht des vorliegenden Optimierungsanspruchs und hinsichtlich der Würdigung der begrenzten Fahrreichweite der elektrischen Fahrzeuge.

Aus ersterem Einwand bezüglich der Optimalität lässt sich die denkbare Forderung ableiten, dass die Anzahl an Touren der Anzahl verfügbarer Fahrzeuge entsprechen soll. Hiermit kann eine vollumfassende Auslastung des bestehenden Fuhrparks erreicht werden. Letzterer Einwand mag auf die Betrachtung eines heterogenen Fuhrparks hinauslaufen. Die Heranziehung von herkömmlichen auf Benzin oder Diesel betriebenen oder hybriden Fahrzeugen könnte beispielsweise dadurch in Betracht kommen. Elektrische Fahrzeuge, die bei erneuter Antretung einer Tour ihre Reichweitenbegrenzung überschreiten würden, könnten durch ebengenannte herkömmliche oder hybride Varianten ersetzt werden. Vor dem Hintergrund der Nachhaltigkeit sollte die Verwendung letzterer beider Fahrzeugvarianten im Zuge des Lösungsverfahrens jedoch mit höheren Kostengewichtungen versehen werden. Erst dann, wenn keine elektrisch betriebenen Fahrzeuge mehr nutzbar sind, sollte sich mit ökologisch nachteilhafteren Arten beholfen werden.

------

[1] J. Euchi und A. Yassine, "A hybrid metaheuristic algorithm to solve the electric vehicle routing problem with battery recharging stations for sustainable environmental and energy optimization", _Energy Syst_, Bd. 14, Nr. 1, S. 243–267, Feb. 2023, doi: [10.1007/s12667-022-00501-y](https://doi.org/10.1007/s12667-022-00501-y).

[2] R. Lasch, _Strategisches und operatives Logistikmanagement: Distribution_. Wiesbaden: Springer Fachmedien Wiesbaden, 2020. doi: [10.1007/978-3-658-31869-7](https://doi.org/10.1007/978-3-658-31869-7).

[3] G. Clarke und J. W. Wright, "Scheduling of Vehicles from a Central Depot to a Number of Delivery Points", Operations Research, Bd. 12, Nr. 4, S. 568–581, 1964, [Online]. Verfügbar unter: http://www.jstor.org/stable/167703

[4] N. Mladenović und P. Hansen, "Variable neighborhood search", _Computers & Operations Research_, Bd. 24, Nr. 11, S. 1097–1100, Nov. 1997, doi: [10.1016/S0305-0548(97)00031-2](https://doi.org/10.1016/S0305-0548(97)00031-2).

[5] S. Luke, _Essentials of metaheuristics: a set of undergraduate lecture notes; Online Version 2.0_, 2. ed. S.l.: Lulu, 2013.

[6] E. Gamma, Hrsg., _Design patterns: elements of reusable object-oriented software_. in Addison-Wesley professional computing series. Reading, Mass: Addison-Wesley, 1995.

[7] "sklearn.cluster.DBSCAN — scikit-learn 1.3.0 documentation". [https://scikit-learn.org/stable/modules/generated/sklearn.cluster.DBSCAN.html](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.DBSCAN.html) (zugegriffen 5. Juli 2023).
